//
//  CompilerError.swift
//  SCUMM
//
//  Created by Michael Borgmann on 05/01/2024.
//

import Foundation

enum CLIError: LocalizedError, Equatable {
    
    case missingFrontend
    case unknownFrontend(_ frontend: String)
    case missingBackend(_ runtime: String)
    case unknownBackend(_ backend: String)
    case missingRuntime
    case noBackendSelected(_ runtime: String = "interpreter")
    case unknownRuntime(_ runtime: String)
    case noRuntimeNeeded(_ runtime: String, _ output: String)
    case missingOutput
    case tooManyValues(_ values: [String])
    case missingSources
    case redundantOutput
    
    case unsupportedRuntime(runtime: String, backend: String)
    case noBackendNeeded(backend: String, runtime: String)
    case invalidVersion(version: Int)
    case unsupportedVersion(version: Int)
    case invalidOption(option: String, value: String)
    case missingVersion(backend: String)
    
    /// A human-readable description of the error.
    var errorDescription: String? {
        
        switch self {
            
        case .missingFrontend:
            return "Missing Frontend"
            
        case .unknownFrontend:
            return "Unknown Frontend"

        case .missingBackend:
            return "Missing Backend"
            
        case .unknownBackend:
            return "Unknown Backend"
            
        case .noBackendSelected:
            return "No Backend Selected"
            
        case .missingRuntime:
            return "Missing Runtime"
            
        case .unknownRuntime:
            return "Unknown Runtime"
            
        case .noRuntimeNeeded:
            return "No Runtime Needed"

        case .missingOutput:
            return "Missing Output"
            
        case .tooManyValues:
            return "Too Many Values"
            
        case .missingSources:
            return "Missing Sources"
            
        case .redundantOutput:
            return "Redundant Output"

        //
            
        case .unsupportedRuntime:
            return "Unsupported Runtime"
            
        case .noBackendNeeded:
            return "No Backend Needed"
            
        case .invalidVersion:
            return "Invalid Version"
            
        case .unsupportedVersion:
            return "Unsupported Version"
            
        case .invalidOption:
            return "Invalid Option"
            
        case .missingVersion:
            return "Missing Version"
        }
    }
    
    /// A localized message describing what caused the failure.
    var failureReason: String? {
        
        switch self {
            
        case .missingFrontend:
            return "The compiler pipline needs to specify a parser."
            
        case .unknownFrontend(let frontend):
            return "The parsing frontend '\(frontend)' is unknown."
            
        case .missingBackend(let runtime):
            return "The '\(runtime)' runtime needs a backend to execute compiled bytecode."
            
        case .unknownBackend(let backend):
            return "The backend '\(backend)' to generate bytecode is unknown."
            
        case .noBackendSelected:
            return "No backend selected to generate bytecode."
            
        case .missingRuntime:
            return "No runtime for execution is selected."

        case .unknownRuntime(let runtime):
            return "The runtime '\(runtime)' to execute bytecode is unkown."
        
        case .noRuntimeNeeded(let runtime, let output):
            return "No runtime is need when compiling bytecode into '\(output)', but '--runtime=\(runtime)' is selected."

        case .missingOutput:
            return "The output command line option ('-o' or '--output') is enabled, but no output file for the compiled bytecode has been specified."
            
        case .tooManyValues(let values):
            return "The output command line option ('-o' or '--output') requires only one output file for the generated bytecode, but multiple are passed: \(values.map { "'\($0)'" }.joined(separator: ", "))"
            
        case .missingSources:
            return "No source files to compile are provids in the command line arguments."
            
        case .redundantOutput:
            return "The output command line option ('-o' or '--output') isn't required for interpreted source code."

        //
        
        case .unsupportedRuntime(let runtime, let backend):
            return "The '\(runtime)' runtime isn't supported for the '\(backend)' backend"
            
        case .noBackendNeeded(let backend, let runtime):
            return "The \(runtime) doesn't need a backend to generate code, but '\(backend)' is selected."
            
        case .invalidVersion(let version):
            return "Version \(version) is an invalid SCUMM version."
            
        case .unsupportedVersion(version: let version):
            return "SCUMM version \(version) is not supported."
            
        case .invalidOption(let option, let value):
            return "Option '\(option)' has an invalid value: '\(value)'"
            
        case .missingVersion(let backend):
            return "Missing version for \(backend) script."
        }
    }
    
    /// A localized recovery suggestion to resolve the error.
    var recoverySuggestion: String? {
        
        switch self {
            
        case .missingFrontend:
            return "Ensure to select a correct parsing frontend by adding '--frontend=[PARSER]' as command line argument. By default, the 'decent' parser is chosen."
            
        case .unknownFrontend:
            return "Ensure to select a supported parsing frontend in the command line argumets. This can also be a typo. Supported parsers are: 'decent' or 'pratt'."
            
        case .missingBackend:
            return "Ensure to select a supported runtime by adding '--backend=[VM]' as command line argument. This can also be a typo. Supported runtimes are: 'scumm', 'mojo' or 'xray'."
            
        case .unknownBackend:
            return "Ensure to select a supported backend as bytecode compiler in the command line arguments. This can also be a typo. Supported code genrators are: 'scumm' or 'mojo'."
            
        case .noBackendSelected(let runtime):
            return "Ensure to select a backend to generate bytecode, otherwise the source code will be build for the \(runtime). This can also be a typo. Supported backends are: 'scumm', 'mojo'."
            
        case .missingRuntime:
            return "Ensure to select a runtime to execute bytecode using the command line argument '--runtime=[VM]', or specify the output of the bytecode compilation using the command line argument '-o | --output BYTECODE' . This can also be a typo. Supported runtimes are: 'scumm', 'mojo' or 'xray'."
            
        case .unknownRuntime:
            return "Ensure to select a supported runtime to execute bytecode in the command line arguments. This can also be a typo. Supported runtimes are: 'scumm', 'mojo' or 'xray'."
            
        case .noRuntimeNeeded:
            return "Ensure to remove the '--runtime' option from the command line arguments to compile into a bytecode file. Otherwise, to execute in the runtime, remove the output option '-o | --output [OUTPUT]'."
            
        case .missingOutput:
            return "Ensure to specify the output file for the compiled bytecode in the command line by adding the filename to the output option: '-o bytecode.scumm' or '--output bytecode.mojo'."
            
        case .tooManyValues:
            return "Ensure to specify the output file for the compiled bytecode in the command line by adding the filename to the output option: '-o bytecode.scumm' or '--output bytecode.mojo'."
            
        case .missingSources:
            return "Ensure to specify sources files to the command line arguments by adding them using as: 'scumm [OPTION] SOURCE'."
            
        case .redundantOutput:
            return "Ensure to remove the output command line option, or properly configure the compiler chain."
            
        case .unsupportedRuntime:
            return nil
            
        case .noBackendNeeded:
            return nil
            
        case .invalidVersion:
            return nil
            
        case .unsupportedVersion:
            return nil
            
        case .invalidOption:
            return nil
            
        case .missingVersion:
            return nil
        }
    }
}
