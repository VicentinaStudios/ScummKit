//
//  DecentParser.swift
//
//
//  Created by Michael Borgmann on 03/01/2024.
//

import Foundation

/// The `DecentParser` class is responsible for parsing a sequence of tokens into an abstract syntax tree (AST) representation.
///
/// It takes a stream of tokens generated by the `Scanner` and organizes them into a hierarchical structure
/// that represents the syntactic structure of the source code. The resulting abstract syntax tree can then be
/// used for further compilation and interpretation of the programming language.
///
/// # Usage
/// To use the `DecentParser`, create an instance with the tokens obtained from the `Scanner` and call
/// `parse()` to obtain the root of the abstract syntax tree.
///
/// ```swift
/// let sourceCode = "if x > 0 { print('Positive') } else { print('Non-positive') }"
/// let scanner = Scanner(source: sourceCode)
///
/// do {
///     let tokens = try scanner.scanAllTokens()
///     let parser = DecentParser(tokens: tokens)
///     let abstractSyntaxTree = try parser.parse()
///     // Use the abstract syntax tree for further compilation or interpretation
/// } catch let error as ParserError {
///     // Handle parsing errors
///     print("Parsing error: \(error.localizedDescription)")
/// }
/// ```
/// - SeeAlso:
///   - `Scanner` for tokenizing the source code into tokens before parsing.
///   - `ParserError` for potential errors during parsing.
///   - `Expression` representing the nodes of the abstract syntax tree.
///   - `Token` representing the individual tokens generated by the scanner.
///   - `TokenType` enumerates the possible types of tokens.
class DecentParser {
    
    // MARK: Properties
    
    /// The array of tokens to be parsed.
    private let tokens: [Token]
    
    /// The current index position in the `tokens` array.
    private var current: Array.Index
    
    /// Errors encountered during parsing, if any.
    private var errors: [Error]?
    
    // MARK: Computed Properties
    
    /// The current token being pointed to by the parser.
    private var peek: Token {
        tokens[current]
    }
    
    /// The previous token relative to the current position.
    private var previous: Token {
        tokens[tokens.index(before: current)]
    }
    
    /// Checks if the parser has reached the end of the token sequence.
    private var isEndOfFile: Bool {
        peek.type == .eof
    }
    
    /// Read-only access to parsing errors.
    var collectedErrors: [Error]? {
        errors
    }
    
    // MARK: Lifecycle
    
    /// Initializes a new instance of the `DecentParser` with a given array of tokens.
    ///
    /// - Parameter tokens: The array of tokens to be parsed.
    init(tokens: [Token]) {
        self.tokens = tokens
        self.current = tokens.startIndex
    }
    
    // MARK: Actions
    
    /// Parses the sequence of tokens into an abstract syntax tree (AST) representation.
    ///
    /// - Returns: The root node of the AST.
    /// - Throws: A `ParserError` if parsing encounters an issue.
    func parse() throws -> Expression {
        try expression()
    }
    
    /// Parses a sequence of statements and returns an array of AST nodes.
    ///
    /// - Returns: An array of `Statement` AST nodes.
    /// - Throws: A `ParserError` if a statement cannot be parsed.
    func parse() throws -> [Statement] {
        
        var statements: [Statement] = []
        
        while !isEndOfFile {
            if let statement = try declaration() {
                statements.append(statement)
            }
        }
        
        if errors != nil {
            print("Parsing completed with errors: \(errors!.count)")
        }
        
        return statements
    }
}

// MARK: - Parser

extension DecentParser {
    
    /// Advances the parser to the next token.
    ///
    /// - Returns: The token that was previously pointed to.
    private func advance() -> Token {
        
        if !isEndOfFile {
            current = tokens.index(after: current)
        }
        
        return previous
    }

    /// Recovers from a parsing error by advancing the parser to a safe point in the code.
    /// The parser skips over invalid tokens until it encounters a valid token, such as a semicolon,
    /// `var`, or `print`, to resume parsing.
    ///
    /// - Note: This function has no return value; it merely advances the parser's position.
    private func synchronize() {
        
        _ = advance()
        
        while !isEndOfFile {
            
            if previous.type == .semicolon {
                return
            }
            
            switch peek.type {
            case .var, .print:
                return
            default:
                break
            }
            
            _ = advance()
        }
    }
    
    /// Parses a declaration.
    ///
    /// - Returns: The parsed declaration.
    /// - Throws: A `ParserError` if parsing encounters an issue.
    private func declaration() throws -> Statement? {
        
        do {
            if match(types: [.var]) {
                return try variableDeclaration()
            } else {
                return try statement()
            }
        } catch {
            
            errors = (errors ?? []) + [error]
            synchronize()
            return nil
        }
    }
    
    /// Parses a variable declaration, which includes the declaration of a new variable
    /// and optionally an initializer expression.
    ///
    /// - Returns: A `VariableStatement` representing the variable declaration. This includes the variable's name
    ///           and its initializer expression (if present).
    /// - Throws:
    ///   - `ParserError.expectedVariableName`: If the token doesn't match an expected variable name (identifier).
    ///   - `ParserError.missingSemicolon`: If the semicolon is missing at the end of the declaration.
    private func variableDeclaration() throws -> Statement {
        
        let variableName = try consume(type: .identifier, error: ParserError.missingVariable(line: peek.line))
        let initializer = match(types: [.equal]) ? try expression() : nil
        
        _ = try consume(type: .semicolon, error: ParserError.missingSemicolon(line: peek.line))
        
        return VariableStatement(name: variableName, initializer: initializer)
    }
    
    /// Parses a statement.
    ///
    /// - Returns: The parsed statement.
    /// - Throws: A `ParserError` if parsing encounters an issue.
    private func statement() throws -> Statement {
        
        if match(types: [.print]) {
            return try printStatement()
        } else {
            return try expressionStatement()
        }
    }
    
    /// Parses an expression.
    ///
    /// - Returns: The parsed expression.
    /// - Throws: A `ParserError` if parsing encounters an issue.
    private func expression() throws -> Expression {
        try assignment()
    }
    
    /// Parses an assignment expression, which may involve assigning a value to a variable.
    ///
    /// - Returns: An `AssignExpression` if an assignment is detected, otherwise, the parsed expression.
    /// - Throws: A `ParserError.invalidAssignment` error if an invalid assignment is attempted (e.g., attempting
    ///           to assign to something that is not a variable).
    private func assignment() throws -> Expression {
        
        let expression = try equality()
        
        if match(types: [.equal]) {
            
            let equals = previous
            let value = try assignment()
            
            guard let expression = expression as? VariableExpression else {
                throw ParserError.invalidAssignment(line: equals.line)
            }
            
            return AssignExpression(name: expression.name, value: value)
        }
        
        return expression
    }
    
    /// Consumes the current token if it matches the expected type; otherwise, throws a `ParserError`.
    ///
    /// - Parameters:
    ///   - type: The expected token type. If the current token does not match this type, the specified error is thrown.
    ///   - error: The error to throw if the current token does not match the expected type. Typically, this will be a
    ///     `ParserError` indicating what went wrong, such as an unexpected token or a missing semicolon.
    /// - Returns: The consumed `Token` if the current token matches the expected type.
    /// - Throws: The provided `error` if the current token does not match the expected type.
    private func consume(type: TokenType, error: Error) throws -> Token {
        
        guard check(type: type) else {
            throw error
        }
        
        return advance()
    }
}

// MARK: - Parse Statements

extension DecentParser {
    
    /// Parses a print statement and consumes the required semicolon.
    ///
    /// - Returns: A `Print` statement, which is a type of `Statement` representing the `print` command.
    /// - Throws: A `ParserError.missingSemicolon` error if the semicolon is not found after the statement.
    private func printStatement() throws -> Statement {
        let expression = try expression()
        _ = try consume(type: .semicolon, error: ParserError.missingSemicolon(line: peek.line))
        return Print(expression: expression)
    }
    
    /// Parses a general expression statement and consumes the required semicolon.
    ///
    /// - Returns: An `ExpressionStmt` statement, representing the parsed expression in statement form.
    /// - Throws: A `ParserError.missingSemicolon` error if the semicolon is not found after the statement.
    private func expressionStatement() throws -> Statement {
        let expression = try expression()
        _ = try consume(type: .semicolon, error: ParserError.missingSemicolon(line: peek.line))
        return ExpressionStmt(expression: expression)
    }
}

// MARK: - Parse Expressions

extension DecentParser {
    
    /// Parses binary operations with given operators and next precedence.
    ///
    /// - Parameters:
    ///   - operators: The array of token types representing operators.
    ///   - nextPrecedence: A closure representing the next precedence level.
    /// - Returns: The parsed expression.
    /// - Throws: A `ParserError` if parsing encounters an issue.
    private func binaryOperation(_ operators: [TokenType], _ nextPrecedence: () throws -> Expression) throws -> Expression {
        
        var expression = try nextPrecedence()

        while match(types: operators) {
            
            let operatorToken = previous
            let right = try nextPrecedence()
            
            expression = BinaryExpression(
                left: expression,
                operatorToken: operatorToken,
                right: right
            )
        }

        return expression
    }
    
    /// Parses the equality expression, handling `!=` and `==` operations.
    ///
    /// - Returns: The parsed expression.
    /// - Throws: A `ParserError` if parsing encounters an issue.
    private func equality() throws -> Expression {
        try binaryOperation([.bangEqual, .equalEqual], comparison)
    }
  
    /// Parses the comparison expression, handling `>`, `>=`, `<`, and `<=` operations.
    ///
    /// - Returns: The parsed expression.
    /// - Throws: A `ParserError` if parsing encounters an issue.
    private func comparison() throws -> Expression {
        try binaryOperation([.greater, .greaterEqual, .less, .lessEqual], term)
    }
    
    /// Parses the term expression, handling addition and subtraction operations.
    ///
    /// - Returns: The parsed expression.
    /// - Throws: A `ParserError` if parsing encounters an issue.
    private func term() throws -> Expression {
        try binaryOperation([.minus, .plus], factor)
    }
    
    /// Parses the factor expression, handling multiplication and division operations.
    ///
    /// - Returns: The parsed expression.
    /// - Throws: A `ParserError` if parsing encounters an issue.
    private func factor() throws -> Expression {
        try binaryOperation([.slash, .star], unary)
    }
    
    /// Parses the unary expression, handling negation and unary minus.
    ///
    /// - Returns: The parsed expression.
    /// - Throws: A `ParserError` if parsing encounters an issue.
    private func unary() throws -> Expression {
        
        if match(types: [.bang, .minus]) {
            
            let operatorToken = previous
            let right = try unary()
            
            return UnaryExpression(
                operatorToken: operatorToken,
                right: right
            )
        }
        
        return try primary()
    }
    
    /// Parses the primary expression, handling literals and grouped expressions.
    ///
    /// - Returns: The parsed expression.
    /// - Throws: A `ParserError` if parsing encounters an issue.
    private func primary() throws -> Expression {
        
        if match(types: [.false]) {
            return LiteralExpression(value: false, token: previous)
        }
        
        if match(types: [.true]) {
            return LiteralExpression(value: true, token: previous)
        }
        
        if match(types: [.nil]) {
            return LiteralExpression(value: nil, token: previous)
        }
        
        if match(types: [.number, .string]) {
            return LiteralExpression(value: previous.literal, token: previous)
        }
        
        if match(types: [.identifier]) {
            return VariableExpression(name: previous)
        }
        
        if match(types: [.leftParen]) {
            
            let expression = try expression()
            _ = try consume(type: .rightParen, error: ParserError.missingBracket(line: peek.line))
            
            return GroupingExpession(expression: expression)
        }
        
        throw ParserError.expressionExpected(line: peek.line)
    }
}

// MARK: - Helper

extension DecentParser {
    
    /// Attempts to match the current token's type with a set of expected types.
    ///
    /// - Parameter types: The expected token types.
    /// - Returns: `true` if a match is found; otherwise, `false`.
    private func match(types: [TokenType]) -> Bool {
        
        for type in types {
            if check(type: type) {
                current = tokens.index(after: current)
                return true
            }
        }
        
        return false
    }
    
    /// Checks if the current token's type matches the expected type.
    ///
    /// - Parameter type: The expected token type.
    /// - Returns: `true` if the types match; otherwise, `false`.
    private func check(type: TokenType) -> Bool {
        isEndOfFile ? false : peek.type == type
    }
}
