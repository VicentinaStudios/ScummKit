//
//  GenerateMojo.swift
//
//
//  Created by Michael Borgmann on 02/01/2024.
//

import Foundation

/// A code generator for the Mojo virtual machine, producing bytecode from statements.
///
/// This class extends the `BaseCodeGenerator` class and implements the necessary bytecode generation logic
/// specific to the Mojo virtual machine's opcode set.
class GenerateMojo: BaseCodeGenerator<MojoOpcode> {
    
    // MARK: Actions
    
    /// Generates bytecode for the given statements.
    ///
    /// - Parameter statements: The statements to generate bytecode for.
    /// - Returns: The `Chunk` containing the generated bytecode.
    /// - Throws: An error of type `CodeGeneratorError` if bytecode generation fails.
    override func generateByteCode(statements: [Statement]) throws -> Chunk {
        
        try statements.forEach { statement in
            _ = try execute(statement)
        }
        
        return chunk
    }
    
    // MARK: Helper
    
    /// Emits a constant value into the bytecode.
    ///
    /// - Parameter value: The constant value to emit.
    /// - Throws: An error of type `CodeGeneratorError.tooManyConstants` if too many constants are added to the chunk.
    private func emitConstant(_ value: Value) throws {
        try emitBytes(MojoOpcode.constant.rawValue, UInt8(makeConstant(value)))
    }
    
    /// Adds a constant value to the chunk's constant pool.
    ///
    /// - Parameter value: The constant value to add.
    /// - Returns: The index of the added constant.
    /// - Throws: An error of type `CodeGeneratorError.tooManyConstants` if too many constants are added to the chunk.
    private func makeConstant(_ value: Value) throws -> Int {
        
        let constant = chunk.addConstant(value: value)
        
        guard constant <= UInt8.max else {
            throw CodeGeneratorError.tooManyConstants
        }
        
        return constant
    }
    
    /// Generates a constant index for an identifier token.
    ///
    /// This method creates an `object` constant for the given identifier token (usually a string) and adds it
    /// to the constant pool.
    ///
    /// - Parameter token: The token representing the identifier.
    /// - Returns: The index of the added constant in the chunk's constant pool.
    /// - Throws: An error of type `CodeGeneratorError.tooManyConstants` if the constant pool exceeds the allowed size.
    private func identifierConstant(token: Token) throws -> Int {
        return try makeConstant(.object(.init(type: .string(token.lexeme))))
    }
    
    // MARK: Expression Visitor
    
    /// Visits a literal expression and emits the corresponding bytecode.
    ///
    /// This method generates the corresponding bytecode for a literal expression. The line number for the literal
    /// expression is retrieved from the expression's `token` if available; otherwise, the `line` from the surrounding
    /// context (e.g., `Unary`, `Binary` expressions) is used. It handles various types of literals including `Int`,
    /// `Double`, `Bool`, `String`, and `nil`. For string literals, the quotes are removed before storing the value
    /// as an object on the heap in the VM.
    ///
    /// - Parameter expression: The literal expression to visit, which contains the value and token information.
    /// - Returns: The literal value, typically used by the visitor pattern to return the result of the expression.
    /// - Throws:
    ///   - `CodeGeneratorError.unknownLiteral`: If the literal value's type is unknown (not `Int`, `Double`, `Bool`, `String`, or `nil`).
    override func visitLiteralExpr(_ expression: LiteralExpression) throws -> Any? {
        
        // Retrieve the line from the expression's token, or fall back to the previous expression's line (context-aware).
        line = expression.token?.line ?? line
        
        switch expression.value {
            
        case let intValue as Int:
            try emitConstant(.int(intValue))
            
        case let doubleValue as Double:
            try emitConstant(.double(doubleValue))
            
        case let boolValue as Bool:
            try emitBytes(boolValue ? MojoOpcode.true.rawValue : MojoOpcode.false.rawValue)
            
        case let stringValue as String:
            let trimmed = String(stringValue.dropFirst().dropLast())
            try emitConstant(.object(.init(type: .string(trimmed))))
            
        case nil:
            try emitBytes(MojoOpcode.nil.rawValue)
            
        default:
            throw CodeGeneratorError.unknownLiteral
        }
                
        return expression.value
    }
    
    /// Visits a grouping expression and evaluates its inner expression.
    ///
    /// - Parameter expression: The grouping expression to visit.
    /// - Throws: An error of type `CodeGeneratorError.expressionEvaluationFailed` if evaluation fails.
    override func visitGroupingExpr(_ expression: GroupingExpession) throws -> Any? {
        
        try evaluate(expression.expression)
    }
    
    /// Visits a unary expression, emits the corresponding bytecode, and returns the result of the unary operation.
    ///
    /// - Parameter expression: The unary expression to visit.
    /// - Returns: The result of the unary operation.
    /// - Throws: An error of type `CodeGeneratorError.expressionEvaluationFailed` if evaluation fails.
    override func visitUnaryExpr(_ expression: UnaryExpression) throws -> Any? {
        
        line = expression.operatorToken.line
        
        switch expression.operatorToken.type {
        
        case .minus:
            
            guard let right = try evaluate(expression.right) else {
                throw CodeGeneratorError.expressionEvaluationFailed
            }
            
            try emitBytes(MojoOpcode.negate.rawValue)
            
            switch right {
            case let rightInt as Int:
                return -rightInt
            case let rightDouble as Double:
                return -rightDouble
            default:
                throw CodeGeneratorError.invalidOperandType
            }
            
        case .bang:
            
            guard
                let right = try evaluate(expression.right) as? Bool
            else {
                throw CodeGeneratorError.expressionEvaluationFailed
            }
            
            try emitBytes(MojoOpcode.not.rawValue)
            return !right
            
        default:
            return nil
        }
    }
    
    /// Visits a binary expression, emits the corresponding bytecode, and returns the result of the binary operation.
    ///
    /// - Parameter expression: The binary expression to visit.
    /// - Returns: The result of the binary operation.
    /// - Throws: An error of type `CodeGeneratorError.expressionEvaluationFailed` if evaluation fails.
    override func visitBinaryExpr(_ expression: BinaryExpression) throws -> Any? {
        
        line = expression.operatorToken.line
        
        let left = try evaluate(expression.left)
        let right = try evaluate(expression.right)
        
        func evaluateBinaryOp<T>(operation: (T, T) -> T) throws -> T? {
            
            if let a = left as? T, let b = right as? T {
                return operation(a, b)
            }
            
            return nil
        }
        
        switch expression.operatorToken.type {
            
        case .minus:
            
            try emitBytes(MojoOpcode.subtract.rawValue)
            
            if let result = try evaluateBinaryOp(operation: -) as Int? { return result }
            if let result = try evaluateBinaryOp(operation: -) as Double? { return result }
            
        case .slash:
            
            try emitBytes(MojoOpcode.divide.rawValue)
            
            if let result = try evaluateBinaryOp(operation: /) as Int? { return result }
            if let result = try evaluateBinaryOp(operation: /) as Double? { return result }
            
        case .star:
            
            try emitBytes(MojoOpcode.multiply.rawValue)
            
            if let result = try evaluateBinaryOp(operation: *) as Int? { return result }
            if let result = try evaluateBinaryOp(operation: *) as Double? { return result }
            
        case .plus:
            
            try emitBytes(MojoOpcode.add.rawValue)
            
            if let result = try evaluateBinaryOp(operation: +) as Int? { return result }
            if let result = try evaluateBinaryOp(operation: +) as Double? { return result }
            if let result = try evaluateBinaryOp(operation: +) as String? { return result }
            
        case .bangEqual:
            
            try emitBytes(MojoOpcode.equal.rawValue, MojoOpcode.not.rawValue)
            
            if let a = left as? Int, let b = right as? Int { return a != b }
            if let a = left as? Double, let b = right as? Double { return a != b }
            if let a = left as? Bool, let b = right as? Bool { return a != b }
            if let a = left as? String, let b = right as? String { return a == b }
            
            return (left == nil) != (right == nil)
            
        case .equalEqual:
            
            try emitBytes(MojoOpcode.equal.rawValue)
            
            if let a = left as? Int, let b = right as? Int { return a == b }
            if let a = left as? Double, let b = right as? Double { return a == b }
            if let a = left as? Bool, let b = right as? Bool { return a == b }
            if let a = left as? String, let b = right as? String { return a == b }
            
            return left == nil && right == nil
            
        case .greater:
            
            try emitBytes(MojoOpcode.greater.rawValue)

            if let a = left as? Int, let b = right as? Int { return a > b }
            if let a = left as? Double, let b = right as? Double { return a > b }
            
        case .greaterEqual:
            
            try emitBytes(MojoOpcode.less.rawValue, MojoOpcode.not.rawValue)
            
            if let a = left as? Int, let b = right as? Int { return a >= b }
            if let a = left as? Double, let b = right as? Double { return a >= b }
            
        case .less:
            
            try emitBytes(MojoOpcode.less.rawValue)
            
            if let a = left as? Int, let b = right as? Int { return a < b }
            if let a = left as? Double, let b = right as? Double { return a < b }
            
        case .lessEqual:
            
            try emitBytes(MojoOpcode.greater.rawValue, MojoOpcode.not.rawValue)
            
            if let a = left as? Int, let b = right as? Int { return a <= b }
            if let a = left as? Double, let b = right as? Double { return a <= b }
            
        default:
            throw CodeGeneratorError.expressionEvaluationFailed
        }
        
        throw CodeGeneratorError.expressionEvaluationFailed
    }
    
    /// Visits a variable expression and retrieves the corresponding value from the chunk.
    ///
    /// This method retrieves the value associated with the given variable expression, which is typically used
    /// to access variables during execution. The variable is identified by its name token.
    ///
    /// - Parameter expression: The variable expression to visit.
    /// - Returns: The value associated with the variable.
    /// - Throws: An error if the variable cannot be found or evaluated.
    override func visitVariableExpr(_ expression: VariableExpression) throws -> Any? {
        
        line = expression.name.line
        
        let argument = try identifierConstant(token: expression.name)
        try emitBytes(MojoOpcode.get.rawValue, UInt8(argument))
        
        return try chunk.readConstant(at: argument).asString
    }
    
    /// Visits an assignment expression and assigns a value to the variable.
    ///
    /// This method processes an assignment expression and assigns the evaluated value to the variable.
    ///
    /// - Parameter expression: The assignment expression to visit.
    /// - Returns: The assigned value.
    /// - Throws: An error if the assignment fails.
    override func visitAssignExpr(_ expression: AssignExpression) throws -> Any? {
        
        line = expression.name.line
        
        guard let value = expression.value else {
            throw InterpreterError.missingOperand(type: "assignment", line: expression.name.line)
        }
        
        let evaluatedValue = try evaluate(value)
        let argument = try identifierConstant(token: expression.name)
        try emitBytes(MojoOpcode.set.rawValue, UInt8(argument))
        return evaluatedValue
    }
    
    // MARK: Statement Visitor
    
    /// Visits a print statement and emits the corresponding bytecode.
    ///
    /// This method processes a print statement, evaluates the expression to be printed, and generates the corresponding
    /// bytecode for printing.
    ///
    /// - Parameter stmt: The print statement to visit.
    /// - Throws: An error if the expression evaluation or bytecode generation fails.
    override func visitPrintStmt(_ stmt: Print) throws -> Void {
        _ = try evaluate(stmt.expression)
        try emitBytes(MojoOpcode.print.rawValue)
    }
    
    /// Visits an expression statement and processes its bytecode.
    ///
    /// This method evaluates the expression in an expression statement and discards its result by emitting the corresponding
    /// bytecode to pop the value.
    ///
    /// - Parameter stmt: The expression statement to visit.
    /// - Throws: An error if expression evaluation or bytecode generation fails.
    override func visitExpressionStmt(_ stmt: ExpressionStmt) throws -> Void {
        _ = try evaluate(stmt.expression)
        try emitBytes(MojoOpcode.pop.rawValue)
    }
    
    /// Visits a variable statement and processes its initialization.
    ///
    /// This method processes a variable declaration, including optional initialization, and generates the appropriate bytecode.
    ///
    /// - Parameter stmt: The variable statement to visit.
    /// - Throws: An error if initialization or bytecode generation fails.
    override func visitVarStmt(_ stmt: VariableStatement) throws -> () {
        
        line = stmt.name.line
        
        let global = try identifierConstant(token: stmt.name)
        
        if let expression = stmt.initializer {
            _ = try evaluate(expression)
            try emitBytes(MojoOpcode.global.rawValue, UInt8(global))
        }
    }
}
