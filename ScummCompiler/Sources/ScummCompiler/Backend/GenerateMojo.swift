//
//  GenerateMojo.swift
//
//
//  Created by Michael Borgmann on 02/01/2024.
//

import Foundation

/// A code generator for the Mojo virtual machine, producing bytecode from expressions.
///
/// This class extends the `BaseCodeGenerator` class and implements the necessary bytecode generation logic
/// specific to the Mojo virtual machine's opcode set.
class GenerateMojo: BaseCodeGenerator<MojoOpcode> {
    
    // MARK: Actions
    
    /// Generates bytecode for the given expression.
    ///
    /// - Parameter expression: The expression to generate bytecode for.
    /// - Returns: The `Chunk` containing the generated bytecode.
    /// - Throws: An error of type `CodeGeneratorError` if bytecode generation fails.
    override func generateByteCode(expression: Expression) throws -> Chunk {
        
        _ = try evaluate(expression)
        
        return chunk
    }
    
    // MARK: Helper
    
    /// Emits a constant value into the bytecode.
    ///
    /// - Parameter value: The constant value to emit.
    /// - Throws: An error of type `CodeGeneratorError.tooManyConstants` if too many constants are added to the chunk.
    private func emitConstant(_ value: Value) throws {
        try emitBytes(MojoOpcode.constant.rawValue, UInt8(makeConstant(value)))
    }
    
    /// Adds a constant value to the chunk's constant pool.
    ///
    /// - Parameter value: The constant value to add.
    /// - Returns: The index of the added constant.
    /// - Throws: An error of type `CodeGeneratorError.tooManyConstants` if too many constants are added to the chunk.
    private func makeConstant(_ value: Value) throws -> Int {
        
        let constant = chunk.addConstant(value: value)
        
        guard constant <= UInt8.max else {
            throw CodeGeneratorError.tooManyConstants
        }
        
        return constant
    }
    
    // MARK: Expression Visitor
    
    /// Visits a literal expression and emits the corresponding bytecode.
    ///
    /// This method generates the corresponding bytecode for a literal expression. The line number for the literal
    /// expression is retrieved from the expression's `token` if available; otherwise, the `line` from the surrounding
    /// context (e.g., `Unary`, `Binary` expressions) is used. It handles various types of literals including `Int`,
    /// `Double`, `Bool`, `String`, and `nil`. For string literals, the quotes are removed before storing the value
    /// as an object on the heap in the VM.
    ///
    /// - Parameter expression: The literal expression to visit, which contains the value and token information.
    /// - Returns: The literal value, typically used by the visitor pattern to return the result of the expression.
    /// - Throws:
    ///   - `CodeGeneratorError.unknownLiteral`: If the literal value's type is unknown (not `Int`, `Double`, `Bool`, `String`, or `nil`).
    override func visitLiteralExpr(_ expression: Literal) throws -> Any? {
        
        // Retrieve the line from the expression's token, or fall back to the previous expression's line (context-aware).
        line = expression.token?.line ?? line
        
        switch expression.value {
            
        case let intValue as Int:
            try emitConstant(.int(intValue))
            
        case let doubleValue as Double:
            try emitConstant(.double(doubleValue))
            
        case let boolValue as Bool:
            try emitBytes(boolValue ? MojoOpcode.true.rawValue : MojoOpcode.false.rawValue)
            
        case let stringValue as String:
            let trimmed = String(stringValue.dropFirst().dropLast())
            try emitConstant(.object(.init(type: .string(trimmed))))
            
        case nil:
            try emitBytes(MojoOpcode.nil.rawValue)
            
        default:
            throw CodeGeneratorError.unknownLiteral
        }
                
        return expression.value
    }
    
    /// Visits a grouping expression and evaluates its inner expression.
    ///
    /// - Parameter expression: The grouping expression to visit.
    /// - Throws: An error of type `CodeGeneratorError.expressionEvaluationFailed` if evaluation fails.
    override func visitGroupingExpr(_ expression: Grouping) throws -> Any? {
        
        try evaluate(expression.expression)
    }
    
    /// Visits a unary expression, emits the corresponding bytecode, and returns the result of the unary operation.
    ///
    /// - Parameter expression: The unary expression to visit.
    /// - Returns: The result of the unary operation.
    /// - Throws: An error of type `CodeGeneratorError.expressionEvaluationFailed` if evaluation fails.
    override func visitUnaryExpr(_ expression: Unary) throws -> Any? {
        
        line = expression.operatorToken.line
        
        switch expression.operatorToken.type {
        
        case .minus:
            
            guard let right = try evaluate(expression.right) else {
                throw CodeGeneratorError.expressionEvaluationFailed
            }
            
            try emitBytes(MojoOpcode.negate.rawValue)
            
            switch right {
            case let rightInt as Int:
                return -rightInt
            case let rightDouble as Double:
                return -rightDouble
            default:
                throw CodeGeneratorError.invalidOperandType
            }
            
        case .bang:
            
            guard
                let right = try evaluate(expression.right) as? Bool
            else {
                throw CodeGeneratorError.expressionEvaluationFailed
            }
            
            try emitBytes(MojoOpcode.not.rawValue)
            return !right
            
        default:
            return nil
        }
    }
    
    /// Visits a binary expression, emits the corresponding bytecode, and returns the result of the binary operation.
    ///
    /// - Parameter expression: The binary expression to visit.
    /// - Returns: The result of the binary operation.
    /// - Throws: An error of type `CodeGeneratorError.expressionEvaluationFailed` if evaluation fails.
    override func visitBinaryExpr(_ expression: Binary) throws -> Any? {
        
        line = expression.operatorToken.line
        
        let left = try evaluate(expression.left)
        let right = try evaluate(expression.right)
        
        func evaluateBinaryOp<T>(operation: (T, T) -> T) throws -> T? {
            
            if let a = left as? T, let b = right as? T {
                return operation(a, b)
            }
            
            return nil
        }
        
        switch expression.operatorToken.type {
            
        case .minus:
            
            try emitBytes(MojoOpcode.subtract.rawValue)
            
            if let result = try evaluateBinaryOp(operation: -) as Int? { return result }
            if let result = try evaluateBinaryOp(operation: -) as Double? { return result }
            
        case .slash:
            
            try emitBytes(MojoOpcode.divide.rawValue)
            
            if let result = try evaluateBinaryOp(operation: /) as Int? { return result }
            if let result = try evaluateBinaryOp(operation: /) as Double? { return result }
            
        case .star:
            
            try emitBytes(MojoOpcode.multiply.rawValue)
            
            if let result = try evaluateBinaryOp(operation: *) as Int? { return result }
            if let result = try evaluateBinaryOp(operation: *) as Double? { return result }
            
        case .plus:
            
            try emitBytes(MojoOpcode.add.rawValue)
            
            if let result = try evaluateBinaryOp(operation: +) as Int? { return result }
            if let result = try evaluateBinaryOp(operation: +) as Double? { return result }
            if let result = try evaluateBinaryOp(operation: +) as String? { return result }
            
        case .bangEqual:
            
            try emitBytes(MojoOpcode.equal.rawValue, MojoOpcode.not.rawValue)
            
            if let a = left as? Int, let b = right as? Int { return a != b }
            if let a = left as? Double, let b = right as? Double { return a != b }
            if let a = left as? Bool, let b = right as? Bool { return a != b }
            
            return (left == nil) != (right == nil)
            
        case .equalEqual:
            
            try emitBytes(MojoOpcode.equal.rawValue)
            
            if let a = left as? Int, let b = right as? Int { return a == b }
            if let a = left as? Double, let b = right as? Double { return a == b }
            if let a = left as? Bool, let b = right as? Bool { return a == b }
            
            return left == nil && right == nil
            
        case .greater:
            
            try emitBytes(MojoOpcode.greater.rawValue)

            if let a = left as? Int, let b = right as? Int { return a > b }
            if let a = left as? Double, let b = right as? Double { return a > b }
            
        case .greaterEqual:
            
            try emitBytes(MojoOpcode.less.rawValue, MojoOpcode.not.rawValue)
            
            if let a = left as? Int, let b = right as? Int { return a >= b }
            if let a = left as? Double, let b = right as? Double { return a >= b }
            
        case .less:
            
            try emitBytes(MojoOpcode.less.rawValue)
            
            if let a = left as? Int, let b = right as? Int { return a < b }
            if let a = left as? Double, let b = right as? Double { return a < b }
            
        case .lessEqual:
            
            try emitBytes(MojoOpcode.greater.rawValue, MojoOpcode.not.rawValue)
            
            if let a = left as? Int, let b = right as? Int { return a <= b }
            if let a = left as? Double, let b = right as? Double { return a <= b }
            
        default:
            throw CodeGeneratorError.expressionEvaluationFailed
        }
        
        throw CodeGeneratorError.expressionEvaluationFailed
    }
}
